<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 16px;
    }
    
    #preview-container {
      width: 100%;
      height: 200px;
      background: #f0f0f0;
      border-radius: 8px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
    }
    
    #preview-canvas {
      width: 100%;
      height: 100%;
    }
    
    .control-group {
      margin-bottom: 20px;
    }
    
    .control-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 12px;
      color: #333;
    }
    
    .control-name {
      font-weight: 500;
    }
    
    .control-value {
      color: #666;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #e0e0e0;
      outline: none;
      -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 8px;
      background: #18a0fb;
      cursor: pointer;
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 8px;
      background: #18a0fb;
      cursor: pointer;
      border: none;
    }
    
    .controls-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    
    .button-group {
      display: flex;
      gap: 8px;
      margin-top: 20px;
    }
    
    button {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    #generate {
      background: #18a0fb;
      color: white;
    }
    
    #generate:hover {
      background: #0d7fd6;
    }
    
    #cancel {
      background: #f0f0f0;
      color: #333;
    }
    
    #cancel:hover {
      background: #e0e0e0;
    }
  </style>
</head>
<body>
  <div id="preview-container">
    <canvas id="preview-canvas"></canvas>
  </div>
  
  <div class="controls-row">
    <div class="control-group">
      <div class="control-label">
        <span class="control-name">Wave Length</span>
        <span class="control-value" id="waveLength-value">100px</span>
      </div>
      <input type="range" id="waveLength" min="20" max="300" value="100">
    </div>
    
    <div class="control-group">
      <div class="control-label">
        <span class="control-name">Wave Height</span>
        <span class="control-value" id="waveHeight-value">50px</span>
      </div>
      <input type="range" id="waveHeight" min="10" max="200" value="50">
    </div>
  </div>
  
  <div class="controls-row">
    <div class="control-group">
      <div class="control-label">
        <span class="control-name">Wave Roundness</span>
        <span class="control-value" id="waveRoundness-value">50%</span>
      </div>
      <input type="range" id="waveRoundness" min="0" max="100" value="50">
    </div>

    <div class="control-group">
      <div class="control-label">
        <span class="control-name">Wave Offset</span>
        <span class="control-value" id="waveOffset-value">0%</span>
      </div>
      <input type="range" id="waveOffset" min="-100" max="100" value="0">
    </div>
  </div>

  <div class="controls-row">
    <div class="control-group">
      <div class="control-label">
        <span class="control-name">Number of Waves</span>
        <span class="control-value" id="numWaves-value">4</span>
      </div>
      <input type="range" id="numWaves" min="1" max="10" value="4">
    </div>
  </div>
  
  <div class="button-group">
    <button id="generate">Generate</button>
    <button id="cancel">Cancel</button>
  </div>

  <script>
    const canvas = document.getElementById('preview-canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size to match container
    function resizeCanvas() {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Slider controls
    const waveLengthSlider = document.getElementById('waveLength');
    const waveHeightSlider = document.getElementById('waveHeight');
    const waveRoundnessSlider = document.getElementById('waveRoundness');
    const waveOffsetSlider = document.getElementById('waveOffset');
    const numWavesSlider = document.getElementById('numWaves');

    // Value displays
    const waveLengthValue = document.getElementById('waveLength-value');
    const waveHeightValue = document.getElementById('waveHeight-value');
    const waveRoundnessValue = document.getElementById('waveRoundness-value');
    const waveOffsetValue = document.getElementById('waveOffset-value');
    const numWavesValue = document.getElementById('numWaves-value');

    // Initialize with default values
    let params = {
      waveLength: parseInt(waveLengthSlider.value),
      waveHeight: parseInt(waveHeightSlider.value),
      waveRoundness: parseInt(waveRoundnessSlider.value),
      waveOffset: parseInt(waveOffsetSlider.value),
      numWaves: parseInt(numWavesSlider.value)
    };
    
    // Update value displays
    function updateValues() {
      waveLengthValue.textContent = params.waveLength + 'px';
      waveHeightValue.textContent = params.waveHeight + 'px';
      waveRoundnessValue.textContent = params.waveRoundness + '%';
      waveOffsetValue.textContent = params.waveOffset + '%';
      numWavesValue.textContent = params.numWaves;
    }
    
    // Event listeners
    waveLengthSlider.addEventListener('input', (e) => {
      params.waveLength = parseInt(e.target.value);
      updateValues();
      drawWave();
    });
    
    waveHeightSlider.addEventListener('input', (e) => {
      params.waveHeight = parseInt(e.target.value);
      updateValues();
      drawWave();
    });
    
    waveRoundnessSlider.addEventListener('input', (e) => {
      params.waveRoundness = parseInt(e.target.value);
      updateValues();
      drawWave();
    });
    
    waveOffsetSlider.addEventListener('input', (e) => {
      params.waveOffset = parseInt(e.target.value);
      updateValues();
      drawWave();
    });

    numWavesSlider.addEventListener('input', (e) => {
      params.numWaves = parseInt(e.target.value);
      updateValues();
      drawWave();
    });

    function lerp(a, b, t) { return a + (b - a) * t; }
    function lerpPt(p0, p1, t) { return { x: lerp(p0.x, p1.x, t), y: lerp(p0.y, p1.y, t) }; }
    function cubicPoint(p0, p1, p2, p3, t) {
      const mt = 1 - t;
      const a = mt * mt * mt;
      const b = 3 * mt * mt * t;
      const c = 3 * mt * t * t;
      const d = t * t * t;
      return {
        x: a * p0.x + b * p1.x + c * p2.x + d * p3.x,
        y: a * p0.y + b * p1.y + c * p2.y + d * p3.y,
      };
    }
    function splitCubic(p0, p1, p2, p3, t) {
      const p01 = lerpPt(p0, p1, t);
      const p12 = lerpPt(p1, p2, t);
      const p23 = lerpPt(p2, p3, t);
      const p012 = lerpPt(p01, p12, t);
      const p123 = lerpPt(p12, p23, t);
      const pm = lerpPt(p012, p123, t);
      return [ [p0, p01, p012, pm], [pm, p123, p23, p3] ];
    }
    function solveTForY(p0, p1, p2, p3, targetY) {
      // Validate that the curve actually crosses the target Y
      const yAtStart = cubicPoint(p0, p1, p2, p3, 0).y;
      const yAtEnd = cubicPoint(p0, p1, p2, p3, 1).y;
      
      // Ensure target is between start and end Y values
      if ((yAtStart > targetY && yAtEnd > targetY) || (yAtStart < targetY && yAtEnd < targetY)) {
        // Fallback: return midpoint if curve doesn't cross targetY
        // This should not happen with normal wave parameters
        return 0.5;
      }
      
      // Determine if curve is ascending (low to high Y) or descending (high to low Y)
      const isAscending = yAtStart < yAtEnd;
      
      let lo = 0, hi = 1;
      for (let i = 0; i < 22; i++) {
        const mid = (lo + hi) / 2;
        const y = cubicPoint(p0, p1, p2, p3, mid).y;
        if (isAscending) {
          // Curve goes from low Y to high Y: if y < targetY, search higher t
          if (y < targetY) lo = mid; else hi = mid;
        } else {
          // Curve goes from high Y to low Y: if y > targetY, search higher t
          if (y > targetY) lo = mid; else hi = mid;
        }
      }
      return (lo + hi) / 2;
    }

    // Draw the wave preview
    function drawWave() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const centerY = canvas.height / 2;
      const padding = 50;
      const startX = padding;
      const endX = canvas.width - padding;

      // Scale the wave to fit in preview
      const totalWaveLength = params.waveLength * params.numWaves;
      const scaleFactor = Math.min((endX - startX) / totalWaveLength, (canvas.height - padding * 2) / (params.waveHeight * 2));
      const scaledWaveLength = params.waveLength * scaleFactor;
      const scaledWaveHeight = params.waveHeight * scaleFactor;
      
      ctx.strokeStyle = '#18a0fb';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      // Wave configuration
      const topY = centerY - scaledWaveHeight;
      const bottomY = centerY + scaledWaveHeight;
      const offsetPercent = params.waveOffset / 100;
      const roundnessPercent = params.waveRoundness / 100;
      
      // Start at bottom left
      ctx.moveTo(startX, bottomY);
      
      // Draw each wave segment
      for (let i = 0; i < params.numWaves; i++) {
        const waveStartX = startX + i * scaledWaveLength;
        const waveMidX = waveStartX + scaledWaveLength / 2;
        const waveEndX = waveStartX + scaledWaveLength;
        
        // Top point position (with offset)
        const topXOffset = offsetPercent * scaledWaveLength;
        const topX = waveMidX + topXOffset;
        
        // Calculate bezier handles based on roundness
        // Roundness determines how far along toward the next point the handles reach
        const handleReach = roundnessPercent * (scaledWaveLength / 2);
        
        // Define points for both cubics
        const p0 = { x: waveStartX, y: bottomY };
        const p1 = { x: waveStartX + handleReach, y: bottomY };
        const p2 = { x: topX - handleReach, y: topY };
        const p3 = { x: topX, y: topY };

        const q0 = { x: topX, y: topY };
        const q1 = { x: topX + handleReach, y: topY };
        const q2 = { x: waveEndX - handleReach, y: bottomY };
        const q3 = { x: waveEndX, y: bottomY };

        // Middle Y coordinate where we want to insert a node
        const middleY = centerY;

        function emitC(a1, a2, a3) {
          ctx.bezierCurveTo(a1.x, a1.y, a2.x, a2.y, a3.x, a3.y);
        }

        // First curve goes from bottom to top
        // Split it at middle Y to add midpoint node
        const tMiddle = solveTForY(p0, p1, p2, p3, middleY);
        const [leftToMiddle, middleToTop] = splitCubic(p0, p1, p2, p3, tMiddle);
        // Emit first half: from bottom to middle Y
        emitC(leftToMiddle[1], leftToMiddle[2], leftToMiddle[3]);
        // Emit second half: from middle Y to top (y = topY) - explicit node at y=topY when going up
        emitC(middleToTop[1], middleToTop[2], middleToTop[3]);
        
        // Second curve goes from top to bottom
        // Split it at middle Y to add midpoint node when going down
        const tMiddleDown = solveTForY(q0, q1, q2, q3, middleY);
        const [topToMiddle, middleToBottom] = splitCubic(q0, q1, q2, q3, tMiddleDown);
        // Emit first half: from top to middle Y (explicit node at y=middleY when going down)
        emitC(topToMiddle[1], topToMiddle[2], topToMiddle[3]);
        // Emit second half: from middle Y to bottom
        emitC(middleToBottom[1], middleToBottom[2], middleToBottom[3]);
      }
      
      ctx.stroke();
    }
    
    // Initial draw
    drawWave();
    
    // Generate button
    document.getElementById('generate').onclick = () => {
      parent.postMessage({ pluginMessage: { type: 'generate-wave', params } }, '*');
    };
    
    // Cancel button
    document.getElementById('cancel').onclick = () => {
      parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
    };
  </script>
</body>
</html>
